# GeometryToolLib

Библиотека для работы с фигурами на плоскости.

## Design

Хотелось, чтобы эта библиотека обладала следующими качествами:

- Удобство использования
- Легкость добавления новых фигур
- Легкость добавления новых операций над фигурами
- Тестируемость

Основной вопрос был: где хранить логику?

Здесь было три основных варианта:

1. Храним логику в самих сущностях, наследуемся и заставляем их реализовывать абстрактные методы. Хранить логику в
   сущностях я не очень люблю, мне нравится визуально отделять модели от логики, особенно когда эта логика имеет
   тенденцию разрастаться. Добавлять новые фигуры будет неудобно - компилятор заставить реализовывать сразу все.
2. Храним логику в методах-расширениях. Представить все фигуры одним интерфейсом и писать к нему методы расширения с
   pattern-matching-ом довольно простой и короткий вариант. Добавление фигуры элементарно и не влечет за собой
   необходимости менять методы с алгоритмами (они отдефолтятся в NotImplemetedException). Вызов методов будет прямо на
   фигурах - клиенту не придется создавать дополнительных классов. Слабость этого подхода - методы статические и не
   могут использовать DI или иметь какой-то стейт. Также не получится менять реализацию для одной операции (а-ля
   стратегию).
3. Храним логику в отдельных классах-сервисах. Думаю, что это самый универсальный вариант. Сервисы могут использовать
   тот же pattern-matching, могут работать с DI, могут содержать стейт и использоваться в стратегии.

P.S.
С моей точки зрения, тот факт, что компилятор не заставляет тебя сразу реализовывать поддержку инструментов для
новодобавленной фигуры - такой же минус, как и плюс. Compile-time проверка того, что для новой фигуры полностью описали
логику во всех инструментах - может помешать забыть эту логику добавить, а вручную добавленные методы с явным
NotImplementedException (это сейчас за секунду делается в ide) позволят увидеть это на MR. В случае, если такого
контроля все-таки хочется, может оказаться удобным применить здесь что-то вроде паттерна Visitor.

```csharp
var triangle = new Triangle(3, 4, 5);

var areaTool = new AreaTool();
var triangleTypeTool = new TriangleTypeDetectionTool();

var area = areaTool.GetArea(triangle);
var isOrthogonal = triangleTypeTool.IsOrthogonal(triangle);
```